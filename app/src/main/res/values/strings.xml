<resources>
    <string name="app_name">学习笔记</string>

    <string name="java_jbgn">
        源文件\n
        源文件(.java)是类的定义，类用来表示程序的一个组件。\n\n
        .class文件\n
        字节码是已经经过编译，但与特定机器码无关，需要解释器转译后才能成为机器码的中间代码。\n\n
        类\n
        类中有一个或多个方法和成员变量。方法必须在类的内部声明。\n\n
        变量\n
        变量是内存中开辟的一块存储区域，用于记录和存储不断变化的数据的值。\n\n
        方法\n
        在方法的花括号中编写方法应该执行的指令。\n\n
        main方法\n
        JVM运行程序的入口就是main方法(public static void main(String[] args)),
        不管程序有多少个类，一定有一个main()来作为程序的起点。\n\n
        JVM\n
        JVM是Java Virtual Machine（Java虚拟机）的缩写。\n
        JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。\n
        JVM实现了平台无关性。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息。\n
        JVM负责运行字节码(.class)。JVM在执行字节码时，把字节码解释成具体平台上的机器指令执行。(Java解释器)\n\n
        Java编译器：\n
        将Java源文件（.java文件）编译成字节码文件（.class文件，是特殊的二进制文件，二进制字节码文件），
        这种字节码就是JVM的“机器语言”。javac.exe可以简单看成是Java编译器。Java编译器可以纠正java源文件的编译错误，
        JVM也要做相同的事情，确保不会有人在执行前修改二进制代码。\n\n
        Java解释器：\n
        是JVM的一部分。Java解释器用来解释执行Java编译器编译后的字节码，
        把字节码解释成具体平台上的机器指令执行。java.exe可以简单看成是Java解释器。\n\n
        运行Java程序的过程：编写.java文件&#8212;>javac编译，生成字节码文件&#8212;>java解释器将字节码解释成具体平台上的机器指令&#8212;>执行指令。\n\n
        注意：通常情况下，一个平台上的二进制可执行文件不能在其他平台上工作，因为此可执行文件包含了对目标处理器的机器语言。
        而Class文件这种特殊的二进制文件，是可以运行在任何支持Java虚拟机的硬件平台和操作系统上的！\n
    </string>
    <string name="java_mxdx">
        面向对象的三个基本特征：\n
        1.封装：把客观事物封装成抽象的类。\n
        2.继承：让某个类型的对象获得另一个类型的对象的属性的方法。\n
        3.多态：一个类实例的相同方法在不同情形有不同表现形式。\n\n
        面向对象的五个基本原则：\n
        1.单一职责原则：类的功能要单一。\n
        2.开放封闭原则：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。\n
        3.替换原则：子类应当可以替换父类并出现在父类能够出现的任何地方。\n
        4.依赖原则：具体依赖抽象，上层依赖下层。\n
        5.接口分离原则：模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来。\n</string>
    <string name="java_bl">
        变量有两种：基本数据类型和引用。\n\n
        Java是强类型定义语言，如果不显示地进行转换，不同类型之间不能转换\n\n
        基本数据类型：\n
        byte：8位(一个字节)。\n
        short：16位(两个字节)。\n
        int：32位(四个字节)。\n
        long：64位(八个字节)。\n
        float：32位(四个字节)。\n
        double：64位(八个字节)。\n
        注意：小的数据类型可以赋值给大的数据类型，反之则不行，会损失精度，也就是所说的溢位，需要强转。\n\n
        引用：\n
        没有对象变量的存在，只有引用到对象的变量。引用变量保存的是存取对象的方法。\n
        引用也是一个变量值，所有引用大小都一样。\n
        对象在失去引用后，就会被标记为可回收，能够被垃圾收集器回收。\n\n
        可以把引用变量想象成遥控器，遥控器上的按钮就是对象的方法。\n\n
        数组也是对象。数组中的变量在内存中的地址是连续的。\n\n
        实例变量声明在类内，局部变量声明在方法内。\n
        实例变量一定有默认值，局部变量没有默认值,局部变量使用前必须初始化。\n
        方法参数也属于局部变量。\n\n
        变量的比较：\n
        使用==比较基本数据类型值是否相等。\n
        使用==比较两个引用是否都指向同一对象。\n
    </string>
    <string name="java_ysf">
        +:加\n
        -:减\n
        *:乘\n
        /:除\n
        =:赋值\n
        &#060;:小于\n
        &#062;:大于\n
        ==:相等\n
        x++:先赋值再加\n
        ++x:先加再赋值\n
        &#038;&#038;:与\n
        ||:或\n
        !:非\n
        !=:不等\n
        a&#060;b?x=a:x=b;:三目运算\n
        &#060;&#060;:左移\n
        &#062;&#062;:右移\n
        &#062;&#062;&#062;:无符号右移,忽略符号位,空位都以0补齐\n
        &#038;:位与\n
        |:位或\n
        ~:位非\n
        ^:位异或\n
    </string>
    <string name="java_ff">
        Java是值传递。\n\n
        调用方法时可以传入一个或多个参数，是将参数拷贝一份再传入的。\n\n
        方法只能声明单一的返回值，或者没有返回值，一旦声明返回值，则必须要返回对应的类型。但是调用方法时可以忽略返回值。\n\n
        方法中可以执行语句，可以进行if&#160;else判断，可以进行while循环，for循环，switch分支语句等。\n\n
        注意：JVM规范里的有一个限制，它规定了一个方法代码长度不能超过65535字节，否则编译会出错！\n\n
    </string>
    <string name="java_fz">
        作用域\t\t\t\t当前类\t\t\t\t同包\t\t\t\t子孙类\t\t\t\t其他包\n
        public\t\t\t\t\t\t\t\t√\t\t\t\t\t\t\t\t√\t\t\t\t\t\t\t\t√\t\t\t\t\t\t\t\t\t√\n
        protected\t\t\t\t     √\t\t\t\t\t\t\t\t√\t\t\t\t\t\t\t\t√\t\t\t\t\t\t\t\t\t×\n
        default\t\t\t\t\t\t\t√\t\t\t\t\t\t\t\t√\t\t\t\t\t\t\t\t×\t\t\t\t\t\t\t\t\t×\n
        private\t\t\t\t\t\t\t\t√\t\t\t\t\t\t\t\t×\t\t\t\t\t\t\t\t×\t\t\t\t\t\t\t\t\t×\n\n
        封装原则：\n
        将不需要对外提供的内容都隐藏起来。\n
        把属性隐藏，提供公共方法对其访问。\n
        封装好处：\n
        一是提高安全性。用private把类的细节与外界隔离起来，从而实现数据项和方法的隐藏，而要访问这些数据项和方法唯一的途径就是通过类本身，
        类才有资格调用它所拥有的资源（方法，数据项属性等等）。\n
        二是提高可维护性。通过隐藏隔离，只允许外部对类做有限的访问，开发者可以自由的改变类的内部实现，而无需修改使用该类的那些程序。
        只要那些在类外部就能被调用的方法保持其外部特征不变，内部代码就可以自由改变，各取所需，利于分工。\n
        三是提高了代码的复用性。封装成工具类以后能够减少很多繁琐的步骤。\n\n
    </string>
    <string name="java_jc">
        继承就是子类继承父类的特征和行为，使得子类具有父类的特征和行为。\n\n
        Java只允许单继承。\n\n
        子类可以覆盖父类的方法，调用子类的方法时，JVM会从继承树形图最下方开始搜索方法。\n\n
        子类会继承父类所有的public类型的实例变量和方法，但不会继承父类所有的private实例变量和方法。\n\n
        子类调用父类方法时，可以用super关键字。\n\n
        继承下来的方法可以被覆盖掉，但实例变量不能被覆盖掉。\n\n
        覆盖方法时不能降低方法的存取权限。\n\n
        覆盖方法时参数必须要一样，且返回类型必须兼容。\n\n
        final修饰的类不能被继承，final修饰的方法不可以被重写，final修饰的变量不能被更改。\n\n
    </string>
    <string name="java_dt">
        什么是多态：\n
        多态可以想象成，用同一个遥控器，控制不同的机器。\n\n
        面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。\n
        多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是方法调用）\n
        实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。\n\n
        多态的作用：消除类型之间的耦合关系。\n
        现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；
        如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。\n\n
        下面是多态存在的三个必要条件，要求大家做梦时都能背出来！\n\n
        多态存在的三个必要条件：\n
        一、要有继承；\n
        二、要有重写；\n
        三、父类引用指向子类对象。\n\n
        注意：编译器是根据引用类型来判断有哪些方法可以调用，为不是根据对象的具体类型！\n
        引用类型可以强转。强转改变的是引用，不是对象。如果强制转换的是基本类型，那改变的是数据本身。\n\n
        强转引用相当于改造了遥控器。如果改造前和改造后不是一个类型的遥控器，编译器就会报错。
        如果改造前和改造后是一个类型的遥控器（子类转父类只是删去按钮，无需强转。父类到子类要增加按钮，需要强转。），但是遥控器上出现对象没有的方法，
        会在运行时按下不存在方法的按钮时报错。\n
        比如：A&#8212;>Object&#8212;>B。\n\n
         多态的好处：\n
        1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。\n
        2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。
        实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。\n
        3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。\n
        4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。\n
        5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。\n
    </string>
    <string name="java_cz">
        重载的方法名称相同，但参数必须不同，返回类型可以不同。\n\n
        重载的方法可以参数数量不同，也可以参数类型不同。\n\n
        重载的方法返回类型可以不同，但是不能只改变返回类型。\n\n
        重载的方法可以任意的设定存取权限。\n\n
        重载的方法只是刚好有相同名字的不同方法，与继承或多态无关。\n\n
    </string>
    <string name="java_jh">
        Collection接口：\n
        \t\tList接口：实现类:LinkedList,Vector,ArrayList\n
        \t\tSet接口：实现类:HashSet,LinkedHashSet\n
        \t\tSortedSet接口：实现类：TreeSet\n
        Map接口：\n
        \t\tMap接口：实现类:HashMap,HashTable,LinkedHashMap,Properties\n\n
        List：有序列表，允许存放重复的元素。\n
        \t\tArrayList：数组实现，需要一块连续的存储空间，查询快，增删慢，不同步，线程不安全，轻量级；\n
        \t\tLinkedList：链表实现，增删快，查询慢；\n
        \t\tVector：数组实现，同步，线程安全，重量级。\n\n
        Set：无序集合，不允许存放重复的元素：\n
        \t\tHashSet： HashSet的后台有一个HashMap，equals返回true，hashCode返回相同的整数，哈希表：存储的数据是无序的；初始化后台容量；
        只不过生成一个HashSet的话，系统只提供key的访问；如果有两个Key重复，那么会覆盖之前的；\n
        \t\tLinkedHashSet：此实现与 HashSet 的不同之外在于，后者维护着一个运行于所有条目的双重链接列表。存储的数据是有序的。\n
        \t\t子接口SortedSet,对Set排序实现类 :TreeSet：使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序；二叉树实现的；\n\n
        Map：键值对：\n
        \t\tHashMap：键值对，key不能重复，但是value可以重复；key的实现就是HashSet；value对应着放；允许null的键或值；\n
        \t\tHashTable：线程安全的，不允许null的键或值；\n
        \t\tProperties：key和value都是String类型，用来读配置文件；\n
        \t\tTreeMap：对key排好序的Map; key 就是TreeSet, value对应每个key；key要实现Comparable接口或TreeMap有自己的构造器；\n
        \t\tLinkedHashMap：此实现与 HashMap 的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。存储的数据是有序的。\n\n
        两个工具类 Arrays 和 Collections：\n
        \t\tArrays、此类包含用来操作数组（比如排序和搜索）的各种方法。\n
        \t\tCollections、主要提供了在 collection 上进行操作的静态方法(同步集合类方法) \n
    </string>
    <string name="java_api">
        在代码中使用类必须写明完整名称，或者使用import语句写在源文件最前面。\n\n
        import只是省去了写类前面的包名而已，程序不会因为使用了import变大或者变慢。\n\n
        java.lang是预先被引用的包。\n\n
    </string>
    <string name="java_cxl">
        抽象类的基本概念：\n
        普通类是一个完善的功能类，可以直接产生实例化对象，并且在普通类中可以包含有构造方法、普通方法、static方法、常量和变量等内容。\n
        而抽象类是指在普通类的结构里面增加抽象方法的组成部分，抽象类无法直接进行实例化操作。\n\n
        抽象方法，是指没有方法体的方法，同时抽象方法还必须使用关键字abstract做修饰。\n\n
        拥有抽象方法的类就是抽象类，抽象类要使用abstract关键字声明。\n\n
        抽象类的使用原则如下： \n
        （1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public； \n
        （2）抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理； \n
        （3）抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类； \n
        （4）子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）；\n\n
    </string>
    <string name="java_jk">
        接口：\n
        接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。
        一个类通过继承接口的方式，从而来继承接口的抽象方法。\n
        接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。\n
        除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。\n
        接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，
        否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。\n\n
        接口与类相似点：\n
        一个接口可以有多个方法。\n
        接口文件保存在 .java 结尾的文件中，文件名使用接口名。\n
        接口的字节码文件保存在 .class 结尾的文件中。\n
        接口相应的字节码文件必须在与包名称相匹配的目录结构中。\n\n
        接口与类的区别：\n
        接口不能用于实例化对象。\n
        接口没有构造方法。\n
        接口中所有的方法必须是抽象方法。\n
        接口不能包含成员变量，除了 static 和 final 变量。\n
        接口不是被类继承了，而是要被类实现。\n
        接口支持多重继承。\n\n
        接口特性：\n
        接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。\n
        接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误。\n
        接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。\n\n
        抽象类和接口的区别：\n
        1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。\n
        2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。\n
        3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。\n
        4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n
        接口的声明：\n
        Interface关键字用来声明一个接口。\n
        接口的实现：\n
        当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。\n
        类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。\n\n
        重写接口中声明的方法时，需要注意以下规则：\n
        类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。\n
        类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。\n
        如果实现接口的类是抽象类，那么就没必要实现该接口的方法。\n\n
        在实现接口的时候，也要注意一些规则：\n
        一个类可以同时实现多个接口。\n
        一个类只能继承一个类，但是能实现多个接口。\n
        一个接口能继承另一个接口，这和类之间的继承比较相似。\n\n
        接口的继承：\n
        一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。\n\n
        接口的多重继承：\n
        在Java中，类的多重继承是不合法，但接口允许多重继承。\n
        在接口的多重继承中extends关键字只需要使用一次，在其后跟着继承接口。\n\n
        标记接口：\n
        最常用的继承接口是没有包含任何方法的接口。\n
        标识接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。\n
        标识接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。\n\n
    </string>
    <string name="java_gzff">
        构造方法：\n
        1.构造方法必须与类同名（如果一个源文件中有多个类，那么构造方法必须与公共类同名）。\n
        2.每个类可以有一个以上的构造方法。\n
        3.构造方法可以有0个、1个或1个以上的参数。\n
        4.构造方法没有返回值。\n
        5.构造方法总是伴随着new操作一起调用。\n
        6.构造方法可以是任意的存取权限。\n
        7.类中可以定义有返回值的并与类同名的方法，但这不是构造方法。\n\n
        继承与构造方法：\n
        使用super调用父类构造方法的语句必须是子类构造方法的第一条语句。\n
        如果子类构造方法没有显式地调用父类的构造方法，则将自动调用父类的默认（没有参数）的构造方法。\n
        如果父类没有不带参数的构造方法，并且在子类的构造器中又没有显式地调用父类的构造方法，则Java编译器将报告错误。\n\n
        总结：父类必须在子类创建之前创建完成。孩子不能在父母之前出生！
    </string>
    <string name="java_ncqy">
        内存区域：\n
        Java虚拟机在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。\n
        Java虚拟机规范将JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。下面详细阐述各数据区所存储的数据类型。\n\n
        程序计数器（Program Counter Register）：\n
        一块较小的内存空间，它是当前线程所执行的字节码的行号指示器，字节码解释器工作时通过改变该计数器的值来选择下一条需要执行的字节码指令，
        分支、跳转、循环等基础功能都要依赖它来实现。每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。\n
        当线程在执行一个Java方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址，当线程在执行的是Native方法（调用本地操作系统方法）时，
        该计数器的值为空。另外，该内存区域是唯一一个在Java虚拟机规范中么有规定任何OOM（内存溢出：OutOfMemoryError）情况的区域。\n\n
        Java虚拟机栈（Java Virtual Machine Stacks）：\n
        该区域也是线程私有的，它的生命周期也与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，
        栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，
        这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。栈帧用于存储局部变量表、操作数栈、
        动态链接、方法返回地址和一些额外的附加信息。在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，
        并且写入了方法表的Code属性之中。因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。\n
        在Java虚拟机规范中，对这个区域规定了两种异常情况：\n
        1、如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。\n
        2、如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。\n
        这两种情况存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。
        在单线程的操作中，无论是由于栈帧太大，还是虚拟机栈空间太小，当栈空间无法分配时，虚拟机抛出的都是StackOverflowError异常，而不会得到OutOfMemoryError异常。
        而在多线程环境下，则会抛出OutOfMemoryError异常。\n
        下面详细说明栈帧中所存放的各部分信息的作用和数据结构。 \n
        1、局部变量表\n
        局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据的类型是编译期可知的各种基本数据类型、对象引用（reference）和returnAddress类型（它指向了一条字节码指令的地址）。局部变量表所需的内存空间在编译期间完成分配，即在Java程序被编译成Class文件时，就确定了所需分配的最大局部变量表的容量。当进入一个方法时，这个方法需要在栈中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
        局部变量表的容量以变量槽（Slot）为最小单位。在虚拟机规范中并没有明确指明一个Slot应占用的内存空间大小（允许其随着处理器、操作系统或虚拟机的不同而发生变化），一个Slot可以存放一个32位以内的数据类型：boolean、byte、char、short、int、float、reference和returnAddresss。reference是对象的引用类型，returnAddress是为字节指令服务的，它执行了一条字节码指令的地址。对于64位的数据类型（long和double），虚拟机会以高位在前的方式为其分配两个连续的Slot空间。
        虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始到局部变量表最大的Slot数量，对于32位数据类型的变量，索引n代表第n个Slot，对于64位的，索引n代表第n和第n+1两个Slot。
        在方法执行时，虚拟机是使用局部变量表来完成参数值到参数变量列表的传递过程的，如果是实例方法（非static），则局部变量表中的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数。其余参数则按照参数表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。
        局部变量表中的Slot是可重用的，方法体中定义的变量，作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超过了某个变量的作用域，那么这个变量对应的Slot就可以交给其他变量使用。这样的设计不仅仅是为了节省空间，在某些情况下Slot的复用会直接影响到系统的而垃圾收集行为。\n
        2、操作数栈\n
        操作数栈又常被称为操作栈，操作数栈的最大深度也是在编译的时候就确定了。32位数据类型所占的栈容量为1,64为数据类型所占的栈容量为2。当一个方法开始执行时，它的操作栈是空的，在方法的执行过程中，会有各种字节码指令（比如：加操作、赋值元算等）向操作栈中写入和提取内容，也就是入栈和出栈操作。
        Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。因此我们也称Java虚拟机是基于栈的，这点不同于Android虚拟机，Android虚拟机是基于寄存器的。
        基于栈的指令集最主要的优点是可移植性强，主要的缺点是执行速度相对会慢些；而由于寄存器由硬件直接提供，所以基于寄存器指令集最主要的优点是执行速度快，主要的缺点是可移植性差。\n
        3、动态连接\n
        每个栈帧都包含一个指向运行时常量池（在方法区中，后面介绍）中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。\n
        4、方法返回地址\n
        当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。
        方法退出的过程实际上等同于把当前栈帧出站，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。\n\n
        本地方法栈（Native Method Stacks）：\n
        该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。\n\n
        Java堆（Java Heap）：\n
        Java Heap是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。
        根据Java虚拟机规范的规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。\n\n
        方法区（Method Area）：\n
        方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区域又被称为“永久代”，但这仅仅对于Sun HotSpot来讲，JRockit和IBM J9虚拟机中并不存在永久代的概念。
        Java虚拟机规范把方法区描述为Java堆的一个逻辑部分，而且它和Java Heap一样不需要连续的内存，可以选择固定大小或可扩展，另外，虚拟机规范允许该区域可以选择不实现垃圾回收。相对而言，垃圾收集行为在这个区域比较少出现。
        该区域的内存回收目标主要针是对废弃常量的和无用类的回收。运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Class文件常量池），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中的常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的是String类的intern（）方法。
        根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。\n\n
        直接内存（Direct Memory）：\n
        直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，它直接从操作系统中分配，因此不受Java堆大小的限制，
        但是会受到本机总内存的大小及处理器寻址空间的限制，因此它也可能导致OutOfMemoryError异常出现。在JDK1.4中新引入了NIO机制，
        它是一种基于通道与缓冲区的新I/O方式，可以直接从操作系统中分配直接内存，即在堆外分配内存，这样能在一些场景中提高性能，
        因为避免了在Java堆和Native堆中来回复制数据。\n\n
        对象实例化分析：\n
        对内存分配情况分析最常见的示例便是对象实例化:\n
        Object obj = new Object();\n
        这段代码的执行会涉及java栈、Java堆、方法区三个最重要的内存区域。假设该语句出现在方法体中，及时对JVM虚拟机不了解的Java使用这，
        应该也知道obj会作为引用类型（reference）的数据保存在Java栈的本地变量表中，而会在Java堆中保存该引用的实例化对象，但可能并不知道，
        Java堆中还必须包含能查找到此对象类型数据的地址信息（如对象类型、父类、实现的接口、方法等），这些类型数据则保存在方法区中。\n
        另外，由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，
        因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄池和直接使用指针。\n
        这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存放的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，
        而reference本身不需要修改。使用直接指针访问方式的最大好处是速度快，它节省了一次指针定位的时间开销。
        目前Java默认使用的HotSpot虚拟机采用的便是是第二种方式进行对象访问的。
    </string>
    <string name="java_gc">
        Java垃圾回收机制，会自动回收无用对象占用的内存空间。\n\n
        引用计数法：\n
        对指向对象的引用计数，计数为0时的对象实例可以当做垃圾收集。\n
        优点：执行速度快，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。\n
        缺点：无法检测出循环引用。\n\n
        根搜索算法：\n
        是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，
        找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。\n
        java中可作为GC Root的对象有：\n
        1.虚拟机栈中引用的对象（本地变量表）\n
        2.方法区中静态属性引用的对象\n
        3. 方法区中常量引用的对象\n
        4.本地方法栈中引用的对象（Native对象）\n\n
        标记-清除算法：\n
        标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收。
        标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，
        但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。\n\n
        标记-整理算法：\n
        标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，
        会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，
        因此成本更高，但是却解决了内存碎片的问题。在基于标记-整理算法的收集器的实现中，一般增加句柄和句柄表。\n\n
        复制算法：\n
        该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成 一个对象面和多个空闲面，
        程序从对象面为对象分配空间，当对象满了，基于复制算法的垃圾 收集就从根集中扫描活动对象，
        并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，
        原来的对象面变成了空闲面，程序会在新的对象面中分配内存。一种典型的基于复制算法的垃圾回收是stop-and-copy算法，
        它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，程序暂停执行。\n\n
        分代算法：\n
        分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。\n
        年轻代（Young Generation）\n
        1.所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。\n
        2.新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。\n
        大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，
        则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，
        即保持survivor1区为空， 如此往复。\n
        3.当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。\n
        4.新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。\n\n
        年老代（Old Generation）\n
        1.在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。\n
        2.内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。\n\n
        持久代（Permanent Generation）\n
        用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，
        例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。\n\n
        新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge\n
        老年代收集器使用的收集器：Serial Old、Parallel Old、CMS\n
        Serial收集器（复制算法)\n
        新生代单线程收集器，标记和清理都是单线程，优点是简单高效。\n
        Serial Old收集器(标记-整理算法)\n
        老年代单线程收集器，Serial收集器的老年代版本。\n
        ParNew收集器(停止-复制算法)\n
        新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。\n
        Parallel Scavenge收集器(停止-复制算法)\n
        并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。\n
        Parallel Old收集器(停止-复制算法)\n
        Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先\n
        CMS(Concurrent Mark Sweep)收集器（标记-清理算法）\n
        高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择。\n\n
        GC的执行机制\n
        由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。\n
        Scavenge GC\n
        一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，
        清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，
        不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。
        因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。\n
        Full GC\n
        对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，
        因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。\n
        有如下原因可能导致Full GC：\n
        1.年老代（Tenured）被写满\n
        2.持久代（Perm）被写满\n
        3.System.gc()被显示调用\n
        4.上一次GC之后Heap的各域分配策略动态变化\n\n
        Java有了GC同样会出现内存泄露问题\n
        1.静态集合类像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，
        所有的对象Object也不能被释放，因为他们也将一直被Vector等应用着。\n
        2.各种连接，数据库连接，网络连接，IO连接等没有显示调用close关闭，不被GC回收导致内存泄露。\n
        3.监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。\n\n
        finalize() 方法：\n
        Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。
        这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。
        它是在 Object 类中定义的，因此所有的类都继承了它。
        子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。\n\n
        那么finalize()究竟是做什么的呢？\n
        它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。
        但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。\n
    </string>
    <string name="java_thread">
        进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1至n个线程。（进程是资源分配的最小单位）。\n\n
　　    线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）。\n\n
        在Java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。\n\n
        每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实例就是在操作系统中启动了一个进程。\n\n
        线程状态转换：\n
        1、新建状态（New）：新创建了一个线程对象。\n
        2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。\n
        3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。\n
        4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：\n
        （一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)。\n
        （二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。\n
        （三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。\n
        当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）。\n
        5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。\n\n
        线程调度：\n
        Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。\n
        每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。\n
        线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。\n
        JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。\n
        2、线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。\n
        3、线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。\n
        4、线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。\n
        5、线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。\n
        6、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。\n
        选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，
        才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；
        例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。\n\n
        常用函数说明：\n
        sleep(): 强迫一个线程睡眠Ｎ毫秒。 \n
        yield():暂停当前正在执行的线程对象，并执行其他线程。\n
        isAlive(): 判断一个线程是否存活。 \n
        join(): 等待线程终止。 \n
        activeCount(): 程序中活跃的线程数。 \n
        enumerate(): 枚举程序中的线程。 \n
        currentThread(): 得到当前线程。 \n
        isDaemon(): 一个线程是否为守护线程。 \n
        setDaemon(): 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程，依赖于主线程结束而结束) 。\n
        setName(): 为线程设置一个名称。 \n
        wait(): 强迫一个线程等待。 \n
        notify(): 通知一个线程继续运行。 \n
        setPriority(): 设置一个线程的优先级。\n\n
        线程同步：\n
        1、线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。\n
        2、线程同步方法是通过锁来实现，每个对象都有且仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他非同步方法。\n
        3、对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。\n
        4、对于同步，要时刻清醒在哪个对象上同步，这是关键。\n
        5、编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。\n
        6、当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。\n
        7、死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真让你写个死锁程序，不一定好使，呵呵。但是，一旦程序发生死锁，程序将死掉。\n
    </string>
    <string name="java_reflect">
        反射机制是什么？\n
        反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；
        这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\n\n
        反射机制的相关API\n\n
        通过一个对象获得完整的包名和类名:\n
        obj.getClass().getName()\n\n
        实例化Class类对象:\n
        Class.forName("类名");\n\n
        实例化一个类的对象:\n
        1.clazz.newInstance()\n
        2.取得全部的构造函数\n
        Constructor&#060;?&#062; cons[] = clazz.getConstructors();\n
        查看每个构造方法需要的参数\n
        Class&#060;?&#062; clazzs[] = cons[i].getParameterTypes();\n
        clazzs[j].getName()\n
        使用构造函数赋值\n
        user = (User) cons[0].newInstance("Rollen");\n\n
        获取一个对象的父类:\n
        clazz.getSuperclass();\n\n
        获取一个对象的实现的接口:\n
        clazz.getInterfaces();\n\n
        获取某个类的全部属性:\n
        clazz.getDeclaredFields();\n\n
        获取某个类的全部方法:\n
        clazz.getMethods();\n\n
        调用某个类的方法:\n
        method.invoke(clazz.newInstance(), 20, "张三");\n\n
        获得注解:\n
        clazz.getAnnotation(),clazz.getAnnotation(A);\n
        field.getAnnotation();\n
        method.getAnnotation();\n
        方法中传入注解的类型，则获得指定类型的注解。无参方法返回所有注解。\n\n
        操作某个类的属性:\n
        可以直接对 private 的属性赋值\n
        Field field = clazz.getDeclaredField("proprety");\n
        field.setAccessible(true);\n
        field.set(obj, "Java反射机制");\n\n
        在泛型为Integer的ArrayList中存放一个String类型的对象。\n
        ArrayList&#060;Integer&#062; list = new ArrayList&#060;Integer&#062;();\n
        Method method = list.getClass().getMethod("add", Object.class);\n
        method.invoke(list, "Java反射机制实例。");\n
        System.out.println(list.get(0));\n
    </string>
    <string name="java_annotation">
        元注解：\n
        元注解的作用就是负责注解其他注解。\n
        1.@Target说明了Annotation所修饰的对象范围。\n
        2.@Retention定义了该Annotation被保留的时间长短。\n
        3.@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。\n
        4.@Inherited元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。\n\n
        自定义注解：\n
        使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。\n
        在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。
        方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。\n\n
        定义注解格式：\n
        public @interface 注解名 {定义体}\n
        注解参数的可支持数据类型：\n
        1.所有基本数据类型（int,float,boolean,byte,double,char,long,short)\n
        2.String类型\n
        3.Class类型\n
        4.enum类型\n
        5.Annotation类型\n
        6.以上所有类型的数组\n\n
        Annotation类型里面的参数该怎么设定: \n
        第一,只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型；\n
        第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,
        以及这一些类型的数组.例如,String value();这里的参数成员就为String;\n
        第三,如果只有一个参数成员,最好把参数名称设为"value",后加小括号。\n\n
        注解元素的默认值：\n
        注解元素必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解元素的值不可为null。
        因此, 使用空字符串或0作为默认值是一种常用的做法。这个约束使得处理器很难表现一个元素的存在或缺失的状态，
        因为每个注解的声明中，所有元素都存在，并且都具有相应的值，为了绕开这个约束，我们只能定义一些特殊的值，
        例如空字符串或者负数，一次表示某个元素不存在，在定义注解时，这已经成为一个习惯用法。\n\n
        例子：\n
        @Target(ElementType.FIELD)\n
        @Retention(RetentionPolicy.RUNTIME)\n
        @Documented\n
        public @interface FruitColor {\n
            /**\n
             * 颜色枚举\n
             * @author peida\n
             *\n
             */\n
            public enum Color{ BULE,RED,GREEN};\n
            /**\n
             * 颜色属性\n
             * @return\n
             */\n
            Color fruitColor() default Color.GREEN;\n
        }\n
    </string>

    <string name="android_selector_desc">1.Button可以显示“未按下” “按下” “失效”三种状态，
        TextView设置clickable=“true”后可以实现一样的效果。\n\n2.当满足多种效果时具体显示效果和xml中定义的顺序有关，
        越靠前优先级越高。例如同时满足“失效”和“未按下”时，哪种效果定义在前面就显示哪种效果。
        所以“失效”一定要定义在最前面。</string>
    <string name="android_permission">
        Normal Permissions:\n
        ACCESS_LOCATION_EXTRA_COMMANDS\n
        ACCESS_NETWORK_STATE\n
        ACCESS_NOTIFICATION_POLICY\n
        ACCESS_WIFI_STATE\n
        BLUETOOTH\n
        BLUETOOTH_ADMIN\n
        BROADCAST_STICKY\n
        CHANGE_NETWORK_STATE\n
        CHANGE_WIFI_MULTICAST_STATE\n
        CHANGE_WIFI_STATE\n
        DISABLE_KEYGUARD\n
        EXPAND_STATUS_BAR\n
        GET_PACKAGE_SIZE\n
        INSTALL_SHORTCUT\n
        INTERNET\n
        KILL_BACKGROUND_PROCESSES\n
        MODIFY_AUDIO_SETTINGS\n
        NFC\n
        READ_SYNC_SETTINGS\n
        READ_SYNC_STATS\n
        RECEIVE_BOOT_COMPLETED\n
        REORDER_TASKS\n
        REQUEST_INSTALL_PACKAGES\n
        SET_ALARM\n
        SET_TIME_ZONE\n
        SET_WALLPAPER\n
        SET_WALLPAPER_HINTS\n
        TRANSMIT_IR\n
        UNINSTALL_SHORTCUT\n
        USE_FINGERPRINT\n
        VIBRATE\n
        WAKE_LOCK\n
        WRITE_SYNC_SETTINGS\n\n
        Dangerous Permissions:\n
        group:android.permission-group.CONTACTS\n
          permission:android.permission.WRITE_CONTACTS\n
          permission:android.permission.GET_ACCOUNTS\n
          permission:android.permission.READ_CONTACTS\n\n
        group:android.permission-group.PHONE\n
          permission:android.permission.READ_CALL_LOG\n
          permission:android.permission.READ_PHONE_STATE\n
          permission:android.permission.CALL_PHONE\n
          permission:android.permission.WRITE_CALL_LOG\n
          permission:android.permission.USE_SIP\n
          permission:android.permission.PROCESS_OUTGOING_CALLS\n
          permission:com.android.voicemail.permission.ADD_VOICEMAIL\n\n
        group:android.permission-group.CALENDAR\n
          permission:android.permission.READ_CALENDAR\n
          permission:android.permission.WRITE_CALENDAR\n\n
        group:android.permission-group.CAMERA\n
          permission:android.permission.CAMERA\n\n
        group:android.permission-group.SENSORS\n
          permission:android.permission.BODY_SENSORS\n\n
        group:android.permission-group.LOCATION\n
          permission:android.permission.ACCESS_FINE_LOCATION\n
          permission:android.permission.ACCESS_COARSE_LOCATION\n\n
        group:android.permission-group.STORAGE\n
          permission:android.permission.READ_EXTERNAL_STORAGE\n
          permission:android.permission.WRITE_EXTERNAL_STORAGE\n\n
        group:android.permission-group.MICROPHONE\n
          permission:android.permission.RECORD_AUDIO\n\n
        group:android.permission-group.SMS\n
          permission:android.permission.READ_SMS\n
          permission:android.permission.RECEIVE_WAP_PUSH\n
          permission:android.permission.RECEIVE_MMS\n
          permission:android.permission.RECEIVE_SMS\n
          permission:android.permission.SEND_SMS\n
          permission:android.permission.READ_CELL_BROADCASTS\n
    </string>

    <string name="arithmetic_structure">
        线性表：（一对一）\n
        线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。\n\n
        1.数组：数组是一种大小固定的数据结构，存储单元是连续的。\n
        2.链表：链表是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。\n
        3.栈：访问、插入和删除元素只能在栈顶进行（先进后出）。\n
        4.队列：元素只能从队列尾插入，从队列头访问和删除（先进先出）。\n\n
        树：（一对多）\n
        树是由n（n>=1）个有限节点组成一个具有层次关系的集合。它具有以下特点：\n
        每个节点有零个或多个子节点；\n
        没有父节点的节点称为根节点；\n
        每一个非根节点有且只有一个 父节点；\n
        除了根节点外，每个子节点可以分为多个不相交的子树。\n\n
        1.二叉树：二叉树是每个节点最多有两棵子树的树结构。通常子树被称作“左子树”和“右子树”。二叉树常被用于实现二叉查找树和二叉堆。\n
        2.二叉查找树：二叉查找树就是二叉排序树，也叫二叉搜索树。二叉查找树或者是一棵空树，或者是具有下列性质的二叉树：\n
        (1) 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n
        (2) 若右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n
        (3) 左、右子树也分别为二叉排序树；\n
        (4) 没有键值相等的结点。\n
        3.平衡二叉树：\n
        平衡二叉树又称AVL树，它或者是一棵空树，或者是具有下列性质的二叉树：\n
        左子树和右子树都是平衡二叉树。\n
        左子树和右子树的深度之差的绝对值不超过1。\n
        4.红黑树：\n
        红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。\n
        红黑树放弃了追求完全平衡，追求大致平衡。\n
        在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:\n
        性质1. 节点是红色或黑色。\n
        性质2. 根节点是黑色。\n
        性质3 每个叶节点（NIL节点，空节点）是黑色的。\n
        性质4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)。\n
        性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。\n\n
        图：（多对多）\n
    </string>

    <string name="design_sjyz">
        1. 单一职责原则(SRP) \n
        定义：就一个类而言，应该仅有一个引起它变化的原因。\n\n
        2. 开放封闭原则(ASD)\n
        定义：类、模块、函数等等等应该是可以拓展的，但是不可修改。\n\n
        3.里氏替换原则(LSP)\n
        定义：所有引用基类（父类）的地方必须能透明地使用其子类的对象。\n\n
        4.依赖倒置原则(DIP)\n
        定义：高层模块不应该依赖低层模块，两个都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。\n\n
        5.迪米特原则(LOD)\n
        定义：一个软件实体应当尽可能少地与其他实体发生相互作用。\n\n
        6.接口隔离原则(ISP)\n
        定义：一个类对另一个类的依赖应该建立在最小的接口上。 \n\n
    </string>
    <string name="design_jdgc">
        简单工厂模式：\n
        定义：提供一个创建对象实例的功能，而无需关心其具体的实现，被创建的实例的类型可以是接口，抽象类，也可以是具体的类。\n\n
        简单工厂的本质是：选择实现。\n\n
        简单工厂的优点：\n
        （1）帮助封装：简单工厂虽然很简单，但帮助我们实现了组件的封装，然后让组件外部能真正面向接口编程。\n
        （2）解耦：通过简单工厂，实现了客户端和具体实现类的解耦。\n
        缺点：\n
        （1）可能增加客户端的复杂度\n
        如果通过客户端的参数来选择具体的实现类，必须让客户端能理解各个参数所代表的具体功能和含义，增加客户端使用的难度，也暴漏了内部实现，可以选用通过配置的方式类实现。\n
    </string>
    <string name="design_wg">
        外观模式：\n
        定义：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n\n
        外观模式的本质是： 封装交互，简化调用。\n\n
        对设计原则的体现：\n
        体现了“最少知识原则”\n\n
        何时选用外观模式\n
        1：如果你希望为一个复杂的子系统提供一个简单接口的时候，可以考虑使用外观模式，使用外观对象来实现大部分客户需要的功能，从而简化客户的使用。\n
        2：如果想要让客户程序和抽象类的实现部分松散耦合，可以考虑使用外观模式，使用外观对象来将这个子系统与它的客户分离开来，从而提高子系统的独立性和可移植性。\n
        3：如果构建多层结构的系统，可以考虑使用外观模式，使用外观对象作为每层的入口，这样可以简化层间调用，也可以松散层次之间的依赖关系。\n
    </string>
    <string name="design_spq">
        适配器模式：\n
        定义：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的哪些类可以一起工作。\n\n
        适配器模式的本质是：转换匹配，复用功能。\n\n
        何时选用适配器模式\n
        如果想：使用一个已经存在的类，但是他的接口不符合你的需求，这种情况可以使用适配器模式，来把已有的实现转换成你需要的接口。\n
        如果想：创建一个可以服用的类，这个类可能和一些不兼容的类一起工作，这种情况可以使用适配器模式。\n
    </string>
    <string name="design_dl">
        单例模式定义：\n
        保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n
        懒汉式和饿汉式实现\n
        懒汉式\n
        （1）私有化构造方法\n
        （2）提供获取实例的方法\n
        （3）把获取实例的方法变成静态的\n
        （4）定义存储实例的属性\n
        （5）把这个属性也定义成静态的\n
        （6）实现控制实例的创建\n\n
        饿汉式\n
        （1）私有化构造方法\n
        （2）提供获取实例的方法\n
        （3）把获取实例的方法变成静态的\n
        （4）定义一个静态变量来存储创建好的类实例，并在定义的时候直接初始化\n
        （5）直接使用已经创建好的实例\n\n
        单例模式的优缺点\n
        1：时间和空间\n
        比较上面两种写法：\n
        懒汉式是典型的时间换空间，也就是每次获取实例都会进行判断，看是否需要创建实例，费判断的时间，
        当然，如果一直没有人使用的话，那就不会创建实例，节约内存空间。\n
        饿汉式是典型的空间换时间，当类装载的时候就会创建类实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断了，节省了运行时间。\n
        2：线程安全\n
        （1）从线程安全性上讲，不加同步的懒汉式是线程不安全的，比如说：有两个线程，一个是线程A，一个是线程B，它们同时调用getInstance方法，那就可能导致并发问题。\n
        （2）饿汉式是线程安全的，因为虚拟机保证了只会装载一次，在装载类的时候是不会发生并发的。\n
        （3）如何实现懒汉式的线程安全呢？(双重检查加锁)\n\n
        public static  Singleton getInstance(){  \n
            //先检查实例是否存在，如果不存在才进入下面的同步块  \n
            if(instance == null){  \n
                //同步块，线程安全的创建实例  \n
                synchronized(Singleton.class){  \n
                    //再次检查实例是否存在，如果不存在才真的创建实例  \n
                    if(instance == null){  \n
                        instance = new Singleton();  \n
                    }  \n
                }  \n
            }  \n
            return instance;  \n
        }\n
    </string>
    <string name="design_gcff">
        工厂方法模式：\n
        定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法模式使一个类的实例化延迟到其子类。\n\n
        工厂方法模式的本质：延迟到子类来选择实现。\n\n
        对设计原则的体现\n
        工厂方法模式很好的体现了“依赖倒置原则”。\n\n
        3：何时选用工厂方法模式\n
        建议在如下情况中，选用工厂方法模式：\n
        如果一个类需要创建某个接口的对象，但是又不知道具体的实现，这种情况可以选用工厂方法模式，把创建对象的工作延迟到子类去实现 \n
        如果一个类本身就希望，由它的子类来创建所需的对象的时候，应该使用工厂方法模式\n
    </string>
    <string name="design_cxgc">
        抽象工厂模式：\n
        提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。\n\n
        适用性\n
        一个系统要独立于它的产品的创建、组合和表示时。\n
        一个系统要由多个产品系列中的一个来配置时。\n
        当你要强调一系列相关的产品对象的设计以便进行联合使用时。\n
        当你提供一个产品类库，而只想显示它们的接口而不是实现时。\n
    </string>
    <string name="design_scq">
        生成器模式：\n
        定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n\n
        生成器模式的本质：分离整体构建算法和部件构造。\n\n
        何时选用生成器模式\n
        建议在如下情况中，选用生成器模式：\n
        如果创建对象的算法，应该独立于该对象的组成部分以及它们的装配方式时\n
        如果同一个构建过程有着不同的表示时\n
    </string>
    <string name="design_yx">
        原型模式：\n
        定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。\n\n
        原型模式的本质：克隆生成对象 。\n\n
        何时选用原型模式\n
        建议在如下情况中，选用原型模式：\n
        如果一个系统想要独立于它想要使用的对象时，可以使用原型模式，让系统只面向接口编程，在系统需要新的对象的时候，可以通过克隆原型来得到\n
        如果需要实例化的类是在运行时刻动态指定时，可以使用原型模式，通过克隆原型来得到需要的实例\n
    </string>
    <string name="design_zjz">
        中介者模式\n
        用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n\n
        适用性\n
        一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。\n
        一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象。\n
        想定制一个分布在多个类中的行为，而又不想生成太多的子类。\n
    </string>
    <string name="design_dlms">
        代理模式\n
        为其他对象提供一种代理以控制对这个对象的访问。\n\n
        适用性\n
        在需要用比较通用和复杂的对象指针代替简单的指针的时候，使用Proxy模式。下面是一 些可以使用Proxy模式常见情况：\n
        远程代理（Remote Proxy）为一个对象在不同的地址空间提供局部代表。\n
        虚代理（Virtual Proxy）根据需要创建开销很大的对象。\n
        保护代理（Protection Proxy）控制对原始对象的访问。保护代理用于对象应该有不同 的访问权限的时候。\n
        智能指引（Smart Reference）取代了简单的指针，它在访问对象时执行一些附加操作。 它的典型用途包括：\n
        对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放它（也称为SmartPointers）。\n
        当第一次引用一个持久对象时，将它装入内存。\n
        在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。\n
    </string>
    <string name="design_gcz">
        观察者模式\n
        定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。\n\n
        适用性\n
        当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。\n
        当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。\n
        当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧密耦合的。\n
    </string>
    <string name="design_ml">
        命令模式\n
        将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作\n\n
        适用性\n
        像上面讨论的MenuItem对象那样，抽象出待执行的动作以参数化某对象。你可用过程语言中的回调（callback）函数表达这种参数化机制。
        所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。Command模式是回调机制的一个面向对象的替代品。\n
        在不同的时刻指定、排列和执行请求。一个Command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，
        那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。\n
        支持取消操作。Command的Execute操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。Command接口必须添加一个Execute操作，
        该操作取消上一次Execute调用的效果。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消”和“重做”。\n
        支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。在Command接口中添加装载操作和存储操作，可以用来保持变动的一个一致的修改日志。
        从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新执行它们。\n
        用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务（Transaction）的信息系统中很常见。
        一个事务封装了对数据的一组变动。Command模式提供了对事务进行建模的方法。Command有一个公共的接口，使得你可以用同一种方式调用所有的事务。
        同时使用该模式也易于添加新事务以扩展系统。\n
    </string>
    <string name="design_ddq">
        迭代器模式\n
        提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。\n\n
        适用性\n
        访问一个聚合对象的内容而无需暴露它的内部表示。\n
        支持对聚合对象的多种遍历。\n
        为遍历不同的聚合结构提供一个统一的接口（即, 支持多态迭代）。\n
    </string>
    <string name="design_zh">
        组合模式\n
        将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。\n\n
        适用性\n
        你想表示对象的部分—整体层次结构。\n
        你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。\n
    </string>
    <string name="design_mbff">
        模版方法模式\n
        定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模版方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n
        适用性\n
        一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。\n
        各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。
        这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。
        最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。\n
        控制子类扩展。模板方法只在特定点调用“hook”操作，这样就只允许在这些点进行扩展。\n
    </string>
    <string name="design_cl">
        策略模式\n
        定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。\n\n
        适用性\n
        许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。\n
        需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间/时间权衡的算法。当这些变体实现为一个算法的类层次时，可以使用策略模式。\n
        算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。\n
        一个类定义了多种行为, 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。\n
    </string>
    <string name="design_zt">
        状态模式\n
        允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。\n\n
        适用性\n
        一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。\n
        一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。
        通常, 有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。
        这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。\n
    </string>
    <string name="design_bwl">
        备忘录模式\n
        在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。\n\n
        适用性\n
        必须保存一个对象在某一个时刻的(部分)状态, 这样以后需要时它才能恢复到先前的状态。\n
        如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。\n
    </string>
    <string name="design_xy">
        享元模式\n
        运用共享技术有效地支持大量细粒度的对象。\n\n
        适用性\n
        一个应用程序使用了大量的对象。\n
        完全由于使用大量的对象，造成很大的存储开销。\n
        对象的大多数状态都可变为外部状态。\n
        如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。\n
        应用程序不依赖于对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。\n
    </string>
    <string name="design_jsq">
        解析器模式\n
        给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。\n\n
        适用性\n
        当有一个语言需要解释执行, 并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好：\n
        该文法简单对于复杂的文法, 文法的类层次变得庞大而无法管理。此时语法分析程序生成器这样的工具是更好的选择。
        它们无需构建抽象语法树即可解释表达式, 这样可以节省空间而且还可能节省时间。\n
        效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的, 而是首先将它们转换成另一种形式。
        例如，正则表达式通常被转换成状态机。但即使在这种情况下, 转换器仍可用解释器模式实现, 该模式仍是有用的。\n
    </string>
    <string name="design_zs">
        装饰模式\n
        动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。\n\n
        适用性\n
        在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。\n
        处理那些可以撤消的职责。\n
        当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。
        另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。\n
    </string>
    <string name="design_zrl">
        职责链模式\n
        使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n
        适用性\n
        有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。\n
        你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。\n
        可处理一个请求的对象集合应被动态指定。\n
    </string>
    <string name="design_qj">
        桥接模式\n
        将抽象部分与它的实现部分分离\n\n
        适用性\n
        你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。\n
        类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时B r i d g e 模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。\n
        对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。\n
        （C++）你想对客户完全隐藏抽象的实现部分。在C++中，类的表示在类接口中是可见的。\n
        有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。Rumbaugh称这种类层次结构为“嵌套的普化”（nested generalizations ）。\n
        你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。一个简单的例子便是Coplien的String类，
        在这个类中多个对象可以共享同一个字符串表示（StringRep）。\n
    </string>
    <string name="design_fwz">
        访问者模式\n
        表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。\n\n
        适用性\n
        一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。\n
        需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。
        Visitor使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作。\n
        定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。
        如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。\n
    </string>

    <string name="linux_kjj">
        Tab：具有命令补全和档案补全的功能\n\n
        Ctrl+C：强制终止当前的进程\n\n
        Ctrl+D：两个功能，一是代表键盘输入的结束；二是用来取代exit命令。\n\n
        Ctrl+L：清屏\n\n
        Ctrl+K：删除从光标到行末的所有字符\n\n
        Ctrl+U：键清除当前行，与ctrl+K相反，删除从光标到行首的所有字符\n\n
        Ctrl+A：移动光标到行首\n\n
        Ctrl+E：移动光标到行尾\n\n
        Shift+Ctrl+T:新建标签页\n\n
        Shift+Ctrl+W:关闭标签页\n\n
        Ctrl+PageUp:前一标签页\n\n
        Ctrl+PageDown:后一标签页\n\n
        Shift+Ctrl+PageUp:标签页左移\n\n
        Shift+Ctrl+PageDown:标签页右移\n\n
        Alt+1:切换到标签页1\n\n
        Alt+2:切换到标签页2\n\n
        Alt+3:切换到标签页3\n\n
        Shift+Ctrl+N:新建窗口\n\n
        Shift+Ctrl+Q:关闭终端\n\n
        终端中的复制／粘贴:\n
        Shift+Ctrl+C:复制\n
        Shift+Ctrl+V:粘贴\n\n
        终端改变大小：\n
        F11：全屏\n
        Ctrl+plus:放大\n
        Ctrl+minus:减小\n
        Ctrl+0:原始大小\n
    </string>
    <string name="linux_mljbcz">
        install\n
        安装或升级软件或备份数据\n\n
        tree\n
        树状图列出目录的内容\n\n
        popd\n
        用于删除目录栈中的记录\n\n
        pushd\n
        将目录加入命令堆叠中\n\n
        dirs\n
        显示目录记录\n\n
        rmdir\n
        用来删除空目录\n\n
        mkdir\n
        用来创建目录\n\n
        rm\n
        用于删除给定的文件和目录\n\n
        pwd\n
        绝对路径方式显示用户当前工作目录\n\n
        ls\n
        显示目录内容列表\n\n
        mv\n
        用来对文件或目录重新命名\n\n
        cp\n
        将源文件或目录复制到目标文件或目录中\n\n
        cd\n
        切换用户当前工作目录\n
    </string>
    <string name="linux_wjczhbj">
        strings\n
        在对象文件或二进制文件中查找可打印的字符串\n\n
        diff\n
        比较给定的两个文件的不同\n\n
        cmp\n
        比较两个文件是否有差异\n\n
        diff3\n
        比较3个文件不同的地方\n\n
        locate/slocate\n
        查找文件或目录\n\n
        which\n
        查找并显示给定命令的绝对路径\n\n
        find\n
        在指定目录下查找文件\n\n
        whereis\n
        查找二进制程序、代码等相关文件路径\n
    </string>
    <string name="linux_wjnrck">
        hexdump\n
        显示文件十六进制格式\n\n
        od\n
        输出文件的八进制、十六进制等格式编码的字节\n\n
        cat\n
        连接文件并打印到标准输出设备上\n\n
        cut\n
        显示行中的指定部分\n\n
        tail\n
        在屏幕上显示指定文件的末尾若干行\n\n
        head\n
        在屏幕上显示指定文件的开头若干行\n\n
        less\n
        分屏上下翻页浏览文件内容\n\n
        more\n
        显示文件内容，每次显示一屏\n
    </string>
    <string name="linux_wjcl">
        iconv\n
        转换文件的编码方式\n\n
        nl\n
        在Linux系统中计算文件内容行号\n\n
        basename\n
        打印目录或者文件的基本名称\n\n
        unlink\n
        系统调用函数unlink去删除指定的文件\n\n
        pathchk\n
        检查文件中不可移植的部分\n\n
        touch\n
        创建新的空文件\n\n
        rename\n
        用字符串替换的方式批量改变文件名\n\n
        dd\n
        复制文件并对原文件的内容进行转换和格式化处理\n\n
        dirname\n
        去除文件名中的非目录部分\n\n
        updatedb\n
        创建或更新slocate命令所必需的数据库文件\n\n
        ln\n
        用来为文件创件连接\n
    </string>
    <string name="linux_wjbj">
        nano\n
        字符终端文本编辑器\n\n
        sed\n
        功能强大的流式文本编辑器\n\n
        pico\n
        功能强大全屏幕的文本编辑器\n\n
        emacs\n
        功能强大的全屏文本编辑器\n\n
        jed\n
        主要用于编辑代码的编辑器\n\n
        joe\n
        强大的纯文本编辑器\n\n
        ed\n
        单行纯文本编辑器\n\n
        ex\n
        启动vim编辑器的ex编辑模式\n\n
        vi\n
        功能强大的纯文本编辑器\n
    </string>
    <string name="linux_wjqxsxsz">
        dos2unix\n
        将DOS格式文本文件转换成Unix格式\n\n
        setfacl\n
        设置文件访问控制列表\n\n
        umask\n
        用来设置限制新建文件权限的掩码\n\n
        lsattr\n
        查看文件的第二扩展文件系统属性\n\n
        chmod\n
        用来变更文件或目录的权限\n\n
        chown\n
        用来变更文件或目录的拥有者或所属群组\n\n
        chgrp\n
        用来变更文件或目录的所属群组\n\n
        chattr\n
        用来改变文件属性\n\n
        stat\n
        用于显示文件的状态信息\n\n
        file\n
        用来探测给定文件的类型。\n
    </string>
    <string name="linux_wjglfgyhb">
        egrep\n
        在文件内查找指定的字符串\n\n
        fgrep\n
        为文件搜索文字字符串\n\n
        split\n
        分割任意大小的文件\n\n
        grep\n
        强大的文本搜索工具\n\n
        comm\n
        两个文件之间的比较\n\n
        printf\n
        格式化并输出结果\n\n
        expand\n
        将文件的制表符转换为空白字符\n\n
        spell\n
        对文件进行拼写检查\n\n
        pr\n
        将文本文件转换成适合打印的格式\n\n
        look\n
        显示文件中以指定字符串开头的任意行\n\n
        tac\n
        将文件已行为单位的反序输出\n\n
        wc\n
        统计文件的字节数、字数、行数\n\n
        fmt\n
        读取文件后优化处理并输出\n\n
        rev\n
        将文件内容以字符为单位反序输出\n\n
        diffstat\n
        显示diff命令输出信息的柱状图\n\n
        ispell\n
        检查文件中出现的拼写错误\n\n
        uniq\n
        报告或忽略文件中的重复行\n\n
        tee\n
        把数据重定向到给定文件和屏幕上\n\n
        paste\n
        将多个文件按列队列合并\n\n
        sort\n
        将文件进行排序并输出\n\n
        unexpand\n
        将文件的空白字符转换为制表符\n\n
        csplit\n
        将一个大文件分割成小的碎片文件\n\n
        fold\n
        控制文件内容输出时所占用的屏幕宽度\n\n
        join\n
        两个文件中指定栏位内容相同的行连接起来\n\n
        col\n
        过滤控制字符\n\n
        tr\n
        将字符进行替换压缩和删除\n\n
        colrm\n
        删除文件中的指定列\n
    </string>
    <string name="linux_wjysyjy">
        lha\n
        压缩或解压缩lzh格式文件\n\n
        bzcmp\n
        比较两个压缩包中的文件\n\n
        bzcat\n
        解压缩指定的.bz2文件\n\n
        unarj\n
        解压缩由arj命令创建的压缩包\n\n
        zcat\n
        显示压缩包中文件的内容\n\n
        znew\n
        将.Z压缩包重新转化为gzip命令压缩的.gz压缩包\n\n
        zipsplit\n
        将较大的zip压缩包分割成各个较小的压缩包\n\n
        arj\n
        用于创建和管理.arj压缩包\n\n
        gzexe\n
        用来压缩可执行文件\n\n
        bzgrep\n
        使用正则表达式搜索.bz2压缩包中文件\n\n
        compress\n
        使用Lempress-Ziv编码压缩数据文件\n\n
        zfore\n
        强制为gzip格式的压缩文件添加.gz后缀\n\n
        bzless\n
        增强.bz2压缩包查看器\n\n
        bzmore\n
        查看bzip2压缩过的文本文件的内容\n\n
        zipinfo\n
        用来列出压缩文件信息\n\n
        unzip\n
        用于解压缩由zip命令压缩的压缩包\n\n
        bzip2recover\n
        恢复被破坏的.bz2压缩包中的文件\n\n
        tar\n
        Linux下的归档使用工具，用来打包和备份。\n\n
        bunzip2\n
        创一个bz2文件压缩包\n\n
        gunzip\n
        用来解压缩文件\n\n
        bzdiff\n
        直接比较两个.bz2压缩包中文件的不同\n\n
        zip\n
        可以用来解压缩文件\n\n
        bzip2\n
        将文件压缩成bz2格式\n\n
        gzip\n
        用来压缩文件\n\n
        uncompress\n
        用来解压.Z文件\n
    </string>
    <string name="linux_wjbfyhf">
        cpio\n
        用来建立、还原备份档的工具程序\n\n
        restore\n
        所进行的操作和dump指令相反\n\n
        dump\n
        用于备份ext2或者ext3文件系统\n
    </string>
    <string name="linux_wjcs">
        ftp\n
        用来设置文件系统相关功能\n\n
        tftp\n
        在本机和tftp服务器之间使用TFTP协议传输文件\n\n
        scp\n
        加密的方式在本地主机和远程主机之间复制文件\n\n
        ncftp\n
        是增强的的FTP工具\n\n
        rcp\n
        使在两台Linux主机之间的文件复制操作更简单\n
    </string>
    <string name="linux_wjxtgl">
        repquota\n
        报表的格式输出磁盘空间限制的状态\n\n
        e2label\n
        设置第二扩展文件系统的卷标\n\n
        findfs\n
        标签或UUID查找文件系统\n\n
        resize2fs\n
        ext2/ext2文件系统重新设置大小\n\n
        e2image\n
        将处于危险状态的文件系统保存到文件中\n\n
        tune2fs\n
        调整或查看ext2/ext3文件系统的文件系统参数\n\n
        sync\n
        用于强制被改变的内容立刻写入磁盘\n\n
        swapoff\n
        关闭指定的交换空间\n\n
        swapon\n
        激活Linux系统中交换空间\n\n
        quota\n
        显示磁盘已使用的空间与限制\n\n
        quotastats\n
        显示系统当前的磁盘配额运行状态信息\n\n
        edquota\n
        用于编辑指定用户或工作组磁盘配额\n\n
        quotaon\n
        激活Linux内核中指定文件系统的磁盘配额功能\n\n
        quotacheck\n
        检查磁盘的使用空间与限制\n\n
        quotaoff\n
        关闭Linux内核中指定文件系统的磁盘配额功能\n\n
        mkfs\n
        用于在设备上创建Linux文件系统\n\n
        mountpoint\n
        用来判断指定的目录是否是加载点\n\n
        umount\n
        用于卸载已经加载的文件系统\n\n
        e2fsck\n
        用于检查第二扩展文件系统的完整性\n\n
        dumpe2fs\n
        用于打印“ext2/ext3”文件系统的超级块和快组信息\n\n
        mount\n
        用于加载文件系统到指定的加载点\n\n
        fsck\n
        检查并且试图修复文件系统中的错误\n\n
        mke2fs\n
        创建磁盘分区上的“etc2/etc3”文件系统\n
    </string>
    <string name="linux_xtgjhcq">
        halt\n
        关闭正在运行的Linux操作系统\n\n
        ctrlaltdel\n
        设置组合键Ctrl+Alt+Del的功能\n\n
        reboot\n
        重新启动正在运行的Linux操作系统\n\n
        shutdown\n
        用来执行系统关机的命令\n\n
        poweroff\n
        用来关闭计算机操作系统并且切断系统电源\n
    </string>
    <string name="linux_xtaq">
        syslog\n
        系统默认的日志守护进程\n\n
        openssl\n
        强大的安全套接字层密码库\n\n
        logwatch\n
        可定制和可插入式的日志监视系统\n\n
        lastb\n
        列出登入系统失败的用户相关信息\n\n
        sudo\n
        以其他身份来执行命令\n\n
        lastlog\n
        显示系统中所有用户最近一次登录信息\n\n
        logrotate\n
        统日志进行轮转、压缩和删除\n\n
        chroot\n
        把根目录换成指定的目的目录\n\n
        logsave\n
        将命令的输出信息保存到指定的日志文件\n\n
        last\n
        列出目前与过去登入系统的用户相关信息\n
    </string>
    <string name="linux_jchzygl">
        ipcrm\n
        删除消息队列、信号集、或者共享内存标识\n\n
        systemctl\n
        系统服务管理器指令\n\n
        w\n
        显示目前登入系统的用户信息\n\n
        watch\n
        周期性的方式执行给定的指令\n\n
        pidof\n
        查找指定名称的进程的进程号ID号\n\n
        skill\n
        向选定的进程发送信号冻结进程\n\n
        pgrep\n
        设置用户的认证信息，包括用户密码、密码过期时间等\n\n
        renice\n
        修改正在运行的进程的调度优先级\n\n
        nohup\n
        将程序以忽略挂起信号的方式运行起来\n\n
        ipcs\n
        分析消息队列共享内存和信号量\n\n
        pmap\n
        报告进程的内存映射关系\n\n
        nice\n
        改变程序执行的优先权等级\n\n
        service\n
        控制系统服务的实用工具\n\n
        pstree\n
        以树状图的方式展现进程之间的派生关系\n\n
        telint\n
        切换当前正在运行系统的运行等级\n\n
        killall\n
        使用进程的名称来杀死一组进程\n\n
        runlevel\n
        打印当前Linux系统的运行等级\n\n
        batch\n
        在系统不繁忙的时候执行定时任务\n\n
        ps\n
        报告当前系统的进程状态\n\n
        init\n
        init进程是所有Linux进程的父进程\n\n
        crontab\n
        提交和管理用户的需要周期性执行的任务\n\n
        pkill\n
        可以按照进程名杀死进程\n\n
        atrm\n
        删除待执行任务队列中的指定任务\n\n
        atq\n
        列出当前用户的at任务列表\n\n
        at\n
        在指定时间执行一个任务\n
    </string>
    <string name="linux_xwindows">
        xclip\n
        管理 X 粘贴板\n\n
        xset\n
        设置X-Window系统中的用户爱好的实用工具\n\n
        xlsfonts\n
        列出X Server使用的字体\n\n
        xhost\n
        制哪些X客户端能够在X服务器上显示\n\n
        xlsatoms\n
        列出X服务器内部所有定义的原子成分\n\n
        xauth\n
        显示和编辑被用于连接X服务器的认证信息\n\n
        xlsclients\n
        列出显示器中的客户端应用程序\n\n
        xinit\n
        是Linux下X-Window系统的初始化程序\n\n
        startx\n
        用来启动X Window\n
    </string>
    <string name="linux_selinux">
        restorecon\n
        恢复文件的安全上下文\n\n
        semanage\n
        默认目录的安全上下文查询与修改\n\n
        setsebool\n
        修改SElinux策略内各项规则的布尔值\n\n
        getsebool\n
        查询SElinux策略内各项规则的布尔值\n\n
        sesearch\n
        查询SELinux策略的规则详情\n\n
        seinfo\n
        查询SELinux的策略提供多少相关规则\n\n
        chcon\n
        修改对象（文件）的安全上下文\n
    </string>
    <string name="linux_wlyy">
        axel\n
        多线程下载工具\n\n
        jwhois\n
        whois 客户端服务\n\n
        curl\n
        利用URL规则在命令行下工作的文件传输工具\n\n
        wget\n
        Linux系统下载文件工具\n\n
        telnet\n
        登录远程主机和管理\n\n
        rexec\n
        运程执行Linux系统下命令\n\n
        rsh\n
        连接远程主机并执行命令\n\n
        rlogin\n
        从当前终端登录到远程Linux主机\n\n
        mail\n
        命令行下发送和接收电子邮件\n\n
        mailstat\n
        显示到达的邮件状态\n\n
        lynx\n
        纯文本模式的网页浏览器\n\n
        elm\n
        纯文本邮件客户端程序\n\n
        mailq\n
        显示待发送的邮件队列\n\n
        lftpget\n
        调用lftp指令下载指定的文件\n\n
        elinks\n
        纯文本界面的WWW浏览器\n\n
        ipcalc\n
        简单的IP地址计算器\n\n
        lftp\n
        优秀的文件客户端程序\n
    </string>
    <string name="linux_gjwl">
        tcpreplay\n
        将PCAP包重新发送，用于性能或者功能测试\n\n
        pfctl\n
        PF防火墙的配置命令\n\n
        iptraf\n
        实时地监视网卡流量\n\n
        ss\n
        获取socket统计信息\n\n
        nstat/rtacct\n
        监视SNMP计数器和网络接口状态\n\n
        lnstat\n
        显示Linux系统的网路状态\n\n
        arptables\n
        管理ARP包过滤规则表\n\n
        arpd\n
        收集免费ARP信息\n\n
        tcpdump\n
        一款sniffer工具\n\n
        ip\n
        网络配置工具\n\n
        ip6tables-restore\n
        还原ip6tables表\n\n
        ip6tables-save\n
        保存ip6tables表配置\n\n
        ip6tables\n
        linux中防火墙软件\n\n
        iptables-restore\n
        还原iptables表的配置\n\n
        iptables-save\n
        备份iptables的表配置\n\n
        iptables\n
        Linux上常用的防火墙软件\n
    </string>
    <string name="linux_wlcs">
        hping3\n
        测试网络及主机的安全\n\n
        iperf\n
        网络性能测试工具\n\n
        host\n
        常用的分析域名查询工具\n\n
        tracepath\n
        追踪目的主机经过的路由信息\n\n
        arpwatch\n
        监听网络上ARP的记录\n\n
        nslookup\n
        查询域名DNS信息的工具\n\n
        arping\n
        通过发送ARP协议报文测试网络\n\n
        nc/netcat\n
        用来设置路由器\n\n
        dig\n
        域名查询工具\n\n
        arp\n
        显示和修改IP到MAC转换表\n\n
        ping\n
        测试主机之间网络的连通性\n\n
        traceroute\n
        显示数据包到主机间的路径\n\n
        netstat\n
        查看Linux中网络系统状态信息\n
    </string>
    <string name="linux_wlaq">
        ssh-copy-id\n
        把本地的ssh公钥文件安装到远程主机对应的账户下\n\n
        ssh-agent\n
        ssh密钥管理器\n\n
        ssh-add\n
        把专用密钥添加到ssh-agent的高速缓存中\n\n
        nmap\n
        网络探测和安全审核\n\n
        iptstate\n
        显示iptables的工作状态\n\n
        ssh-keygen\n
        为ssh生成、管理和转换认证密钥\n\n
        sftp-server\n
        sftp协议的服务器端程序\n\n
        sshd\n
        openssh软件套件中的服务器守护进程\n\n
        ssh-keyscan\n
        收集主机公钥的使用工具\n\n
        sftp\n
        交互式的文件传输程序\n\n
        ssh\n
        openssh套件中的客户端连接工具\n
    </string>
    <string name="linux_wlpz">
        mii-tool\n
        配置网络设备协商方式的工具\n\n
        ethtool\n
        显示或修改以太网卡的配置信息\n\n
        nisdomainname\n
        显示主机NIS的域名\n\n
        dhclient\n
        动态获取或释放IP地址\n\n
        domainname\n
        显示和设置系统的NIS域名\n\n
        ypdomainname\n
        显示主机的NIS的域名\n\n
        usernetctl\n
        被允许时操作指定的网络接口\n\n
        dnsdomainname\n
        定义DNS系统中FQDN名称的域名\n\n
        hostname\n
        显示和设置系统的主机名\n\n
        ifup\n
        激活指定的网络接口\n\n
        ifcfg\n
        置Linux中的网络接口参数\n\n
        ifconfig\n
        配置和显示Linux系统网卡的网络参数\n\n
        ifdown\n
        禁用指定的网络接口\n\n
        route\n
        显示并设置Linux中静态路由表\n
    </string>
    <string name="linux_wlfwq">
        mysqlimport\n
        为MySQL服务器用命令行方式导入数据\n\n
        ftpshut\n
        在指定的时间关闭FTP服务器\n\n
        ftpcount\n
        显示目前已FTP登入的用户人数\n\n
        exportfs\n
        管理NFS共享文件系统列表\n\n
        apachectl\n
        Apache服务器前端控制工具\n\n
        ab\n
        Apache服务器的性能测试工具\n\n
        squid\n
        squid服务器守护进程\n\n
        mysql\n
        MySQL服务器客户端工具\n\n
        sendmail\n
        著名电子邮件服务器\n\n
        mysqlshow\n
        显示MySQL中数据库相关信息\n\n
        smbpasswd\n
        samba用户和密码管理工具\n\n
        squidclient\n
        squid服务器的客户端管理工具\n\n
        smbclient\n
        交互方式访问samba服务器\n\n
        showmount\n
        显示NFS服务器加载的信息\n\n
        nfsstat\n
        列出NFS客户端和服务器的工作状态\n\n
        mysqladmin\n
        MySQL服务器管理客户端\n\n
        ftpwho\n
        显示当前每个ftp会话信息\n\n
        mysqldump\n
        MySQL数据库中备份工具\n\n
        htdigest\n
        Apache服务器内置工具\n\n
        htpasswd\n
        apache服务器创建密码认证文件\n\n
        ftptop\n
        proftpd服务器的连接状态\n
    </string>
    <string name="linux_shellnjml">
        sh\n
        shell命令解释器\n\n
        trap\n
        指定在接收到信号后将要采取的动作\n\n
        let\n
        简单的计算器\n\n
        seq\n
        以指定增量从首数开始打印数字到尾数\n\n
        tput\n
        通过terminfo数据库对终端会话进行初始化和操作\n\n
        apropos\n
        在 whatis 数据库中查找字符串\n\n
        set\n
        显示或设置shell特性及shell变量\n\n
        command\n
        调用并执行指定的命令\n\n
        dris\n
        显示和清空目录堆栈中的内容\n\n
        fc\n
        修改历史命令并执行\n\n
        bind\n
        显示或设置键盘按键与其相关的功能\n\n
        readonly\n
        定义只读shell变量或函数\n\n
        read\n
        从键盘读取变量值\n\n
        bg\n
        用于将作业放到后台运行\n\n
        ulimit\n
        控制shell程序的资源\n\n
        enable\n
        启动或关闭shell内建命令\n\n
        declare\n
        声明或显示shell变量\n\n
        wait\n
        等待进程执行完后返回\n\n
        builtin\n
        执行shell内部命令\n\n
        shopt\n
        显示和设置shell操作选项\n\n
        exit\n
        退出当前的shell\n\n
        jobs\n
        显示Linux中的任务列表及任务状态\n\n
        help\n
        显示帮助信息\n\n
        history\n
        用于显示历史命令\n\n
        logout\n
        退出当前登录的Shell\n\n
        export\n
        设置或显示系统环境变量\n\n
        exec\n
        调用并执行指定的命令\n\n
        env\n
        显示系统中已存在的环境变量\n\n
        unset\n
        删除指定的shell变量或函数\n\n
        kill\n
        删除执行中的程序或工作\n\n
        unalias\n
        删除由alias设置的别名\n\n
        type\n
        显示指定命令的类型\n\n
        fg\n
        将后台作业放到前台终端运行\n\n
        alias\n
        用来设置指令的别名\n\n
        echo\n
        输出指定的字符串或者变量\n
    </string>
    <string name="linux_xnjcyyh">
        inotifywait\n
        异步文件系统监控机制\n\n
        nethogs\n
        终端下的网络流量监控工具\n\n
        ifstat\n
        统计网络接口流量状态\n\n
        dstat\n
        通用的系统资源统计工具\n\n
        ltrace\n
        用来跟踪进程调用库函数的情况\n\n
        iotop\n
        用来监视磁盘I/O使用状况的工具\n\n
        strace\n
        跟踪系统调用和信号\n\n
        fuser\n
        使用文件或文件结构识别进程\n\n
        lsof\n
        显示Linux系统当前已打开的所有文件列表\n\n
        tload\n
        显示系统负载状况\n\n
        time\n
        统计给定命令所花费的总时间\n\n
        vmstat\n
        显示虚拟内存状态\n\n
        sar\n
        系统运行状态统计工具\n\n
        mpstat\n
        显示各个可用CPU的状态\n\n
        iostat\n
        监视系统输入输出设备和CPU的使用情况\n\n
        free\n
        显示内存的使用情况\n\n
        uptime\n
        查看Linux系统负载信息\n\n
        top\n
        显示或管理执行中的程序\n
    </string>
    <string name="linux_yjgl">
        losetup\n
        设定与控制循环（loop）设备\n\n
        dmidecode\n
        在Linux系统下获取有关硬件方面的信息\n\n
        hwclock\n
        显示与设定硬件时钟\n\n
        cdrecord\n
        Linux系统下光盘刻录功能命令\n\n
        setpci\n
        查询和配置PCI设备的使用工具\n\n
        lspci\n
        显示当前主机的所有PCI总线信息\n\n
        lsusb\n
        显示本机的USB设备列表信息\n\n
        arch\n
        显示当前主机的硬件架构类型\n\n
        volname\n
        显示指定的ISO-9660格式的设备的卷名称\n\n
        systool\n
        显示基于总线、类和拓扑显示系统中设备的信息\n
    </string>
    <string name="linux_nhymkgl">
        lsb_release\n
        显示发行版本信息\n\n
        sysctl\n
        时动态地修改内核的运行参数\n\n
        slabtop\n
        实时显示内核slab内存缓存信息\n\n
        kernelversion\n
        打印当前内核的主版本号\n\n
        get_module\n
        获取Linux内核模块的详细信息\n\n
        kexec\n
        从当前正在运行的内核引导到一个新内核\n\n
        dmesg\n
        显示Linux系统启动信息\n\n
        uname\n
        显示Linux系统信息\n\n
        depmod\n
        分析可载入模块的相依性\n\n
        bmodinfo\n
        显示给定模块的详细信息\n\n
        modprobe\n
        自动处理可载入模块\n\n
        rmmod\n
        从运行的内核中移除指定的内核模块\n\n
        insmod\n
        将给定的模块加载到内核中\n\n
        lsmod\n
        显示已载入系统的模块\n
    </string>
    <string name="linux_cpgl">
        blkid\n
        查看块设备的文件系统类型、LABEL、UUID等信息\n\n
        du\n
        显示每个文件和目录的磁盘使用空间\n\n
        lsblk\n
        列出块设备信息\n\n
        vgremove\n
        用于用户删除LVM卷组\n\n
        lvresize\n
        调整逻辑卷空间大小\n\n
        lvremove\n
        删除指定LVM逻辑卷\n\n
        lvreduce\n
        收缩逻辑卷空间\n\n
        pvs\n
        输出物理卷信息报表\n\n
        pvchange\n
        修改物理卷属性\n\n
        pvck\n
        检测物理卷的LVM元数据的一致性\n\n
        pvremove\n
        删除一个存在的物理卷\n\n
        lvextend\n
        扩展逻辑卷空间\n\n
        pvdisplay\n
        显示物理卷的属性\n\n
        lvdisplay\n
        显示逻辑卷属性\n\n
        pvscan\n
        扫描系统中所有硬盘的物理卷列表\n\n
        lvscan\n
        扫描逻辑卷\n\n
        lvcreate\n
        用于创建LVM的逻辑卷\n\n
        pvcreate\n
        将物理硬盘分区初始化为物理卷\n\n
        vgconvert\n
        转换卷组元数据格式\n\n
        blockdev\n
        从命令行调用区块设备控制程序\n\n
        mkswap\n
        建立和设置SWAP交换分区\n\n
        vgchange\n
        修改卷组属性\n\n
        mknod\n
        创建字符设备文件和块设备文件\n\n
        mkisofs\n
        建立ISO 9660映像文件\n\n
        mkinitrd\n
        建立要载入ramdisk的映像文件\n\n
        vgreduce\n
        从卷组中删除物理卷\n\n
        hdparm\n
        显示与设定硬盘的参数\n\n
        vgextend\n
        向卷组中添加物理卷\n\n
        partprobe\n
        不重启的情况下重读分区\n\n
        vgscan\n
        扫描并显示系统中的卷组\n\n
        vgcreate\n
        用于创建LVM卷组\n\n
        fdisk\n
        查看磁盘使用情况和磁盘分区\n\n
        badblocks\n
        查找磁盘中损坏的区块\n\n
        vgdisplay\n
        显示LVM卷组的信息\n\n
        mkbootdisk\n
        可建立目前系统的启动盘\n\n
        grub\n
        多重引导程序grub的命令行shell工具\n\n
        convertquota\n
        把老的配额文件转换为新的格式\n\n
        lilo\n
        安装核心载入开机管理程序\n\n
        df\n
        显示磁盘的相关信息\n\n
        parted\n
        磁盘分区和分区大小调整工具\n
    </string>
    <string name="linux_cygjml">
        pssh\n
        批量管理执行\n\n
        screen\n
        用于命令行终端切换\n\n
        speedtest-cli\n
        命令行下测试服务器外网速度\n\n
        clockdiff\n
        检测两台linux主机的时间差\n\n
        ntpdate\n
        使用网络计时协议（NTP）设置日期和时间\n\n
        rsync\n
        远程数据同步工具\n\n
        vdfuse\n
        VirtualBox软件挂载VDI分区文件工具\n\n
        ngrep\n
        方便的数据包匹配和显示工具\n\n
        tempfile\n
        shell中给临时文件命名\n\n
        xargs\n
        给其他命令传递参数的一个过滤器\n\n
        awk\n
        文本和数据进行处理的编程语言\n\n
        yes\n
        重复打印指定字符串\n\n
        date\n
        显示或设置系统时间与日期\n\n
        consoletype\n
        输出已连接的终端类型\n\n
        info\n
        Linux下info格式的帮助指令\n\n
        hostid\n
        用来打印当前主机的数字化标识\n\n
        clear\n
        清除当前屏幕终端上的任何信息\n\n
        whoami\n
        打印当前有效的用户名称\n\n
        users\n
        显示当前登录系统的所有用户\n\n
        sleep\n
        将目前动作延迟一段时间\n\n
        md5sum\n
        计算和校验文件报文摘要的工具程序\n\n
        mesg\n
        设置当前终端的写权限\n\n
        mtools\n
        显示mtools支持的指令\n\n
        login\n
        登录系统或切换用户身份\n\n
        stty\n
        修改终端命令行的相关设置\n\n
        talk\n
        让用户和其他用户聊天\n\n
        man\n
        查看Linux中的指令帮助\n\n
        whatis\n
        查询一个命令执行什么功能\n\n
        write\n
        向指定登录用户终端上发送信息\n\n
        who\n
        显示目前登录系统的用户信息\n\n
        sum\n
        计算文件的校验码和显示块数\n\n
        wall\n
        向系统当前所有打开的终端上输出信息\n\n
        dircolors\n
        置ls命令在显示目录或文件时所用的色彩\n\n
        gpm\n
        提供文字模式下的滑鼠事件处理\n\n
        bc\n
        算术操作精密运算工具\n\n
        cal\n
        显示当前日历或指定日期的日历\n\n
        cksum\n
        检查文件的CRC是否正确\n
    </string>
    <string name="linux_rjbgl">
        dnf\n
        新一代的RPM软件包管理器\n\n
        dpkg-reconfigure\n
        Debian Linux中重新配制一个已经安装的软件包\n\n
        dpkg\n
        Debian Linux系统上安装、创建和管理软件包\n\n
        apt-sortpkgs\n
        Debian Linux下对软件包索引文件进行排序的工具\n\n
        apt-key\n
        管理Debian Linux系统中的软件包密钥\n\n
        aptitude\n
        Debian Linux系统中软件包管理工具\n\n
        apt-get\n
        Debian Linux发行版中的APT软件包管理工具\n\n
        ntsysv\n
        集中管理系统的各种服务\n\n
        chkconfig\n
        检查或设置系统的各种服务\n\n
        rpmsign\n
        使用RPM软件包的签名管理工具\n\n
        rpmdb\n
        初始化和重建RPM数据库\n\n
        yum\n
        基于RPM的软件包管理器\n\n
        rpm\n
        RPM软件包的管理工具\n\n
        dpkg-trigger\n
        Debian Linux下的软件包触发器\n\n
        rcconf\n
        Debian Linux下的运行等级服务配置工具\n\n
        rpmbuild\n
        创建RPM的二进制软件包和源码软件包\n\n
        rpmverify\n
        验证已安装的RPM软件包的正确性\n\n
        rpmquery\n
        从RPM数据库中查询软件包信息\n\n
        patch\n
        为开放源代码软件安装补丁程序\n\n
        rpm2cpio\n
        将RPM软件包转换为cpio格式的文件\n\n
        dpkg-statoverride\n
        Debian Linux中覆盖文件的所有权和模式\n\n
        dpkg-preconfigure\n
        Debian Linux中软件包安装之前询问问题\n\n
        dpkg-split\n
        Debian Linux中将大软件包分割成小包\n\n
        dpkg-query\n
        Debian Linux中软件包的查询工具\n\n
        dpkg-divert\n
        Debian Linux中创建并管理一个转向列表\n\n
        dpkg-deb\n
        Debian Linux下的软件包管理工具\n
    </string>
    <string name="linux_bckf">
        ldconfig\n
        动态链接库管理命令\n\n
        readelf\n
        用于显示elf格式文件的信息\n\n
        objdump\n
        显示二进制文件信息\n\n
        pstack\n
        显示每个进程的栈跟踪\n\n
        indent\n
        格式化C语言的源文件\n\n
        gdb\n
        功能强大的程序调试器\n\n
        gcc\n
        基于C/C++的编译器\n\n
        expr\n
        一款表达式计算工具\n\n
        test\n
        shell环境中测试条件表达式工具\n\n
        php\n
        PHP语言的命令行接口\n\n
        protoize\n
        GNU-C代码转换为ANSI-C代码\n\n
        mktemp\n
        创建临时文件供shell脚本使用\n\n
        perl\n
        perl语言解释器\n\n
        make\n
        GNU的工程化编译工具\n\n
        ldd\n
        打印程序或者库文件所依赖的共享库列表\n\n
        nm\n
        显示二进制目标文件的符号表\n\n
        unprotoize\n
        删除C语言源代码文件中的函数原型\n\n
        ld\n
        将目标文件连接为可执行程序\n\n
        gcov\n
        测试程序的代码覆盖率的工具\n\n
        as\n
        汇编语言编译器\n
    </string>
    <string name="linux_dy">
        reject\n
        指示打印系统拒绝发往指定目标打印机的打印任务\n\n
        lpadmin\n
        配置CUPS套件中的打印机和类\n\n
        cupsenable\n
        启动指定的打印机\n\n
        accept\n
        指示打印系统接受发往指定目标打印机的打印任务\n\n
        lpstat\n
        显示CUPS中打印机的状态信息\n\n
        cupsdisable\n
        停止指定的打印机\n\n
        lpc\n
        命令行方式打印机控制程序\n\n
        cancel\n
        取消已存在的打印任务\n\n
        lp\n
        打印文件或修改排队的打印任务\n\n
        lpq\n
        显示打印队列中的打印任务的状态信息\n\n
        eject\n
        用来退出抽取式设备\n\n
        lprm\n
        删除打印队列中的打印任务\n\n
        lpr\n
        将文件发送给指定打印机进行打印\n
    </string>
</resources>
